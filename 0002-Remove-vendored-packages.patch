From b57a53d5917b2f892aecb61e1847c1f0f4dee6ab Mon Sep 17 00:00:00 2001
From: Jeremy Cline <jeremy@jcline.org>
Date: Tue, 12 Jul 2016 14:03:19 -0400
Subject: [PATCH 2/2] Remove vendored packages

Signed-off-by: Jeremy Cline <jeremy@jcline.org>
---
 clint/packages/__init__.py             |   0
 clint/packages/appdirs.py              | 346 ---------------------------------
 clint/packages/colorama/__init__.py    |   6 -
 clint/packages/colorama/ansi.py        |  49 -----
 clint/packages/colorama/ansitowin32.py | 182 -----------------
 clint/packages/colorama/initialise.py  |  55 ------
 clint/packages/colorama/win32.py       | 123 ------------
 clint/packages/colorama/winterm.py     | 102 ----------
 clint/packages/ordereddict.py          | 127 ------------
 setup.py                               |   1 -
 10 files changed, 991 deletions(-)
 delete mode 100644 clint/packages/__init__.py
 delete mode 100644 clint/packages/appdirs.py
 delete mode 100644 clint/packages/colorama/__init__.py
 delete mode 100644 clint/packages/colorama/ansi.py
 delete mode 100644 clint/packages/colorama/ansitowin32.py
 delete mode 100644 clint/packages/colorama/initialise.py
 delete mode 100644 clint/packages/colorama/win32.py
 delete mode 100644 clint/packages/colorama/winterm.py
 delete mode 100644 clint/packages/ordereddict.py

diff --git a/clint/packages/__init__.py b/clint/packages/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/clint/packages/appdirs.py b/clint/packages/appdirs.py
deleted file mode 100644
index 94c592f..0000000
--- a/clint/packages/appdirs.py
+++ /dev/null
@@ -1,346 +0,0 @@
-#!/usr/bin/env python
-# Copyright (c) 2005-2010 ActiveState Software Inc.
-
-"""Utilities for determining application-specific dirs.
-
-See <http://github.com/ActiveState/appdirs> for details and usage.
-"""
-# Dev Notes:
-# - MSDN on where to store app data files:
-#   http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120
-# - Mac OS X: http://developer.apple.com/documentation/MacOSX/Conceptual/BPFileSystem/index.html
-# - XDG spec for Un*x: http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
-
-__version_info__ = (1, 2, 0)
-__version__ = '.'.join(map(str, __version_info__))
-
-
-import sys
-import os
-
-PY3 = sys.version_info[0] == 3
-
-if PY3:
-    unicode = str
-
-class AppDirsError(Exception):
-    pass
-
-
-
-def user_data_dir(appname, appauthor=None, version=None, roaming=False):
-    r"""Return full path to the user-specific data dir for this application.
-
-        "appname" is the name of application.
-        "appauthor" (only required and used on Windows) is the name of the
-            appauthor or distributing body for this application. Typically
-            it is the owning company name.
-        "version" is an optional version path element to append to the
-            path. You might want to use this if you want multiple versions
-            of your app to be able to run independently. If used, this
-            would typically be "<major>.<minor>".
-        "roaming" (boolean, default False) can be set True to use the Windows
-            roaming appdata directory. That means that for users on a Windows
-            network setup for roaming profiles, this user data will be
-            sync'd on login. See
-            <http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>
-            for a discussion of issues.
-
-    Typical user data directories are:
-        Mac OS X:               ~/Library/Application Support/<AppName>
-        Unix:                   ~/.config/<appname>    # or in $XDG_CONFIG_HOME if defined
-        Win XP (not roaming):   C:\Documents and Settings\<username>\Application Data\<AppAuthor>\<AppName>
-        Win XP (roaming):       C:\Documents and Settings\<username>\Local Settings\Application Data\<AppAuthor>\<AppName>
-        Win 7  (not roaming):   C:\Users\<username>\AppData\Local\<AppAuthor>\<AppName>
-        Win 7  (roaming):       C:\Users\<username>\AppData\Roaming\<AppAuthor>\<AppName>
-
-    For Unix, we follow the XDG spec and support $XDG_CONFIG_HOME. We don't
-    use $XDG_DATA_HOME as that data dir is mostly used at the time of
-    installation, instead of the application adding data during runtime.
-    Also, in practice, Linux apps tend to store their data in
-    "~/.config/<appname>" instead of "~/.local/share/<appname>".
-    """
-    if sys.platform.startswith("win"):
-        if appauthor is None:
-            raise AppDirsError("must specify 'appauthor' on Windows")
-        const = roaming and "CSIDL_APPDATA" or "CSIDL_LOCAL_APPDATA"
-        path = os.path.join(_get_win_folder(const), appauthor, appname)
-    elif sys.platform == 'darwin':
-        path = os.path.join(
-            os.path.expanduser('~/Library/Application Support/'),
-            appname)
-    else:
-        path = os.path.join(
-            os.getenv('XDG_CONFIG_HOME', os.path.expanduser("~/.config")),
-            appname.lower())
-    if version:
-        path = os.path.join(path, version)
-    return path
-
-
-def site_data_dir(appname, appauthor=None, version=None):
-    """Return full path to the user-shared data dir for this application.
-
-        "appname" is the name of application.
-        "appauthor" (only required and used on Windows) is the name of the
-            appauthor or distributing body for this application. Typically
-            it is the owning company name.
-        "version" is an optional version path element to append to the
-            path. You might want to use this if you want multiple versions
-            of your app to be able to run independently. If used, this
-            would typically be "<major>.<minor>".
-
-    Typical user data directories are:
-        Mac OS X:   /Library/Application Support/<AppName>
-        Unix:       /etc/xdg/<appname>
-        Win XP:     C:\Documents and Settings\All Users\Application Data\<AppAuthor>\<AppName>
-        Vista:      (Fail! "C:\ProgramData" is a hidden *system* directory on Vista.)
-        Win 7:      C:\ProgramData\<AppAuthor>\<AppName>   # Hidden, but writeable on Win 7.
-
-    For Unix, this is using the $XDG_CONFIG_DIRS[0] default.
-
-    WARNING: Do not use this on Windows. See the Vista-Fail note above for why.
-    """
-    if sys.platform.startswith("win"):
-        if appauthor is None:
-            raise AppDirsError("must specify 'appauthor' on Windows")
-        path = os.path.join(_get_win_folder("CSIDL_COMMON_APPDATA"),
-                            appauthor, appname)
-    elif sys.platform == 'darwin':
-        path = os.path.join(
-            os.path.expanduser('/Library/Application Support'),
-            appname)
-    else:
-        # XDG default for $XDG_CONFIG_DIRS[0]. Perhaps should actually
-        # *use* that envvar, if defined.
-        path = "/etc/xdg/"+appname.lower()
-    if version:
-        path = os.path.join(path, version)
-    return path
-
-
-def user_cache_dir(appname, appauthor=None, version=None, opinion=True):
-    r"""Return full path to the user-specific cache dir for this application.
-
-        "appname" is the name of application.
-        "appauthor" (only required and used on Windows) is the name of the
-            appauthor or distributing body for this application. Typically
-            it is the owning company name.
-        "version" is an optional version path element to append to the
-            path. You might want to use this if you want multiple versions
-            of your app to be able to run independently. If used, this
-            would typically be "<major>.<minor>".
-        "opinion" (boolean) can be False to disable the appending of
-            "Cache" to the base app data dir for Windows. See
-            discussion below.
-
-    Typical user cache directories are:
-        Mac OS X:   ~/Library/Caches/<AppName>
-        Unix:       ~/.cache/<appname> (XDG default)
-        Win XP:     C:\Documents and Settings\<username>\Local Settings\Application Data\<AppAuthor>\<AppName>\Cache
-        Vista:      C:\Users\<username>\AppData\Local\<AppAuthor>\<AppName>\Cache
-
-    On Windows the only suggestion in the MSDN docs is that local settings go in
-    the `CSIDL_LOCAL_APPDATA` directory. This is identical to the non-roaming
-    app data dir (the default returned by `user_data_dir` above). Apps typically
-    put cache data somewhere *under* the given dir here. Some examples:
-        ...\Mozilla\Firefox\Profiles\<ProfileName>\Cache
-        ...\Acme\SuperApp\Cache\1.0
-    OPINION: This function appends "Cache" to the `CSIDL_LOCAL_APPDATA` value.
-    This can be disabled with the `opinion=False` option.
-    """
-    if sys.platform.startswith("win"):
-        if appauthor is None:
-            raise AppDirsError("must specify 'appauthor' on Windows")
-        path = os.path.join(_get_win_folder("CSIDL_LOCAL_APPDATA"),
-                            appauthor, appname)
-        if opinion:
-            path = os.path.join(path, "Cache")
-    elif sys.platform == 'darwin':
-        path = os.path.join(
-            os.path.expanduser('~/Library/Caches'),
-            appname)
-    else:
-        path = os.path.join(
-            os.getenv('XDG_CACHE_HOME', os.path.expanduser('~/.cache')),
-            appname.lower())
-    if version:
-        path = os.path.join(path, version)
-    return path
-
-def user_log_dir(appname, appauthor=None, version=None, opinion=True):
-    r"""Return full path to the user-specific log dir for this application.
-
-        "appname" is the name of application.
-        "appauthor" (only required and used on Windows) is the name of the
-            appauthor or distributing body for this application. Typically
-            it is the owning company name.
-        "version" is an optional version path element to append to the
-            path. You might want to use this if you want multiple versions
-            of your app to be able to run independently. If used, this
-            would typically be "<major>.<minor>".
-        "opinion" (boolean) can be False to disable the appending of
-            "Logs" to the base app data dir for Windows, and "log" to the
-            base cache dir for Unix. See discussion below.
-
-    Typical user cache directories are:
-        Mac OS X:   ~/Library/Logs/<AppName>
-        Unix:       ~/.cache/<appname>/log  # or under $XDG_CACHE_HOME if defined
-        Win XP:     C:\Documents and Settings\<username>\Local Settings\Application Data\<AppAuthor>\<AppName>\Logs
-        Vista:      C:\Users\<username>\AppData\Local\<AppAuthor>\<AppName>\Logs
-
-    On Windows the only suggestion in the MSDN docs is that local settings
-    go in the `CSIDL_LOCAL_APPDATA` directory. (Note: I'm interested in
-    examples of what some windows apps use for a logs dir.)
-
-    OPINION: This function appends "Logs" to the `CSIDL_LOCAL_APPDATA`
-    value for Windows and appends "log" to the user cache dir for Unix.
-    This can be disabled with the `opinion=False` option.
-    """
-    if sys.platform == "darwin":
-        path = os.path.join(
-            os.path.expanduser('~/Library/Logs'),
-            appname)
-    elif sys.platform == "win32":
-        path = user_data_dir(appname, appauthor, version); version=False
-        if opinion:
-            path = os.path.join(path, "Logs")
-    else:
-        path = user_cache_dir(appname, appauthor, version); version=False
-        if opinion:
-            path = os.path.join(path, "log")
-    if version:
-        path = os.path.join(path, version)
-    return path
-
-
-class AppDirs(object):
-    """Convenience wrapper for getting application dirs."""
-    def __init__(self, appname, appauthor, version=None, roaming=False):
-        self.appname = appname
-        self.appauthor = appauthor
-        self.version = version
-        self.roaming = roaming
-    @property
-    def user_data_dir(self):
-        return user_data_dir(self.appname, self.appauthor,
-            version=self.version, roaming=self.roaming)
-    @property
-    def site_data_dir(self):
-        return site_data_dir(self.appname, self.appauthor,
-            version=self.version)
-    @property
-    def user_cache_dir(self):
-        return user_cache_dir(self.appname, self.appauthor,
-            version=self.version)
-    @property
-    def user_log_dir(self):
-        return user_log_dir(self.appname, self.appauthor,
-            version=self.version)
-
-
-
-
-#---- internal support stuff
-
-def _get_win_folder_from_registry(csidl_name):
-    """This is a fallback technique at best. I'm not sure if using the
-    registry for this guarantees us the correct answer for all CSIDL_*
-    names.
-    """
-    import _winreg
-
-    shell_folder_name = {
-        "CSIDL_APPDATA": "AppData",
-        "CSIDL_COMMON_APPDATA": "Common AppData",
-        "CSIDL_LOCAL_APPDATA": "Local AppData",
-    }[csidl_name]
-
-    key = _winreg.OpenKey(_winreg.HKEY_CURRENT_USER,
-        r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders")
-    dir, type = _winreg.QueryValueEx(key, shell_folder_name)
-    return dir
-
-def _get_win_folder_with_pywin32(csidl_name):
-    from win32com.shell import shellcon, shell
-    dir = shell.SHGetFolderPath(0, getattr(shellcon, csidl_name), 0, 0)
-    # Try to make this a unicode path because SHGetFolderPath does
-    # not return unicode strings when there is unicode data in the
-    # path.
-    try:
-        dir = unicode(dir)
-
-        # Downgrade to short path name if have highbit chars. See
-        # <http://bugs.activestate.com/show_bug.cgi?id=85099>.
-        has_high_char = False
-        for c in dir:
-            if ord(c) > 255:
-                has_high_char = True
-                break
-        if has_high_char:
-            try:
-                import win32api
-                dir = win32api.GetShortPathName(dir)
-            except ImportError:
-                pass
-    except UnicodeError:
-        pass
-    return dir
-
-def _get_win_folder_with_ctypes(csidl_name):
-    import ctypes
-
-    csidl_const = {
-        "CSIDL_APPDATA": 26,
-        "CSIDL_COMMON_APPDATA": 35,
-        "CSIDL_LOCAL_APPDATA": 28,
-    }[csidl_name]
-
-    buf = ctypes.create_unicode_buffer(1024)
-    ctypes.windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)
-
-    # Downgrade to short path name if have highbit chars. See
-    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.
-    has_high_char = False
-    for c in buf:
-        if ord(c) > 255:
-            has_high_char = True
-            break
-    if has_high_char:
-        buf2 = ctypes.create_unicode_buffer(1024)
-        if ctypes.windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):
-            buf = buf2
-
-    return buf.value
-
-if sys.platform == "win32":
-    try:
-        import win32com.shell
-        _get_win_folder = _get_win_folder_with_pywin32
-    except ImportError:
-        try:
-            import ctypes
-            _get_win_folder = _get_win_folder_with_ctypes
-        except ImportError:
-            _get_win_folder = _get_win_folder_from_registry
-
-
-
-#---- self test code
-
-if __name__ == "__main__":
-    appname = "MyApp"
-    appauthor = "MyCompany"
-
-    props = ("user_data_dir", "site_data_dir", "user_cache_dir",
-        "user_log_dir")
-
-    print("-- app dirs (without optional 'version')")
-    dirs = AppDirs(appname, appauthor, version="1.0")
-    for prop in props:
-        print("%s: %s" % (prop, getattr(dirs, prop)))
-
-    print("\n-- app dirs (with optional 'version')")
-    dirs = AppDirs(appname, appauthor)
-    for prop in props:
-        print("%s: %s" % (prop, getattr(dirs, prop)))
diff --git a/clint/packages/colorama/__init__.py b/clint/packages/colorama/__init__.py
deleted file mode 100644
index 147a3e0..0000000
--- a/clint/packages/colorama/__init__.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from .initialise import init, deinit, reinit
-from .ansi import Fore, Back, Style
-from .ansitowin32 import AnsiToWin32
-
-VERSION = '0.2.3'
-
diff --git a/clint/packages/colorama/ansi.py b/clint/packages/colorama/ansi.py
deleted file mode 100644
index 7c45983..0000000
--- a/clint/packages/colorama/ansi.py
+++ /dev/null
@@ -1,49 +0,0 @@
-'''
-This module generates ANSI character codes to printing colors to terminals.
-See: http://en.wikipedia.org/wiki/ANSI_escape_code
-'''
-
-CSI = '\033['
-
-def code_to_chars(code):
-    return CSI + str(code) + 'm'
-
-class AnsiCodes(object):
-    def __init__(self, codes):
-        for name in dir(codes):
-            if not name.startswith('_'):
-                value = getattr(codes, name)
-                setattr(self, name, code_to_chars(value))
-
-class AnsiFore:
-    BLACK   = 30
-    RED     = 31
-    GREEN   = 32
-    YELLOW  = 33
-    BLUE    = 34
-    MAGENTA = 35
-    CYAN    = 36
-    WHITE   = 37
-    RESET   = 39
-
-class AnsiBack:
-    BLACK   = 40
-    RED     = 41
-    GREEN   = 42
-    YELLOW  = 43
-    BLUE    = 44
-    MAGENTA = 45
-    CYAN    = 46
-    WHITE   = 47
-    RESET   = 49
-
-class AnsiStyle:
-    BRIGHT    = 1
-    DIM       = 2
-    NORMAL    = 22
-    RESET_ALL = 0
-
-Fore = AnsiCodes( AnsiFore )
-Back = AnsiCodes( AnsiBack )
-Style = AnsiCodes( AnsiStyle )
-
diff --git a/clint/packages/colorama/ansitowin32.py b/clint/packages/colorama/ansitowin32.py
deleted file mode 100644
index 489a917..0000000
--- a/clint/packages/colorama/ansitowin32.py
+++ /dev/null
@@ -1,182 +0,0 @@
-
-import re
-import sys
-
-from .ansi import AnsiFore, AnsiBack, AnsiStyle, Style
-from .winterm import WinTerm, WinColor, WinStyle
-from .win32 import windll
-
-
-if windll is not None:
-    winterm = WinTerm()
-
-
-def is_a_tty(stream):
-    return hasattr(stream, 'isatty') and stream.isatty()
-
-
-class StreamWrapper(object):
-    '''
-    Wraps a stream (such as stdout), acting as a transparent proxy for all
-    attribute access apart from method 'write()', which is delegated to our
-    Converter instance.
-    '''
-    def __init__(self, wrapped, converter):
-        # double-underscore everything to prevent clashes with names of
-        # attributes on the wrapped stream object.
-        self.__wrapped = wrapped
-        self.__convertor = converter
-
-    def __getattr__(self, name):
-        return getattr(self.__wrapped, name)
-
-    def write(self, text):
-        self.__convertor.write(text)
-
-
-class AnsiToWin32(object):
-    '''
-    Implements a 'write()' method which, on Windows, will strip ANSI character
-    sequences from the text, and if outputting to a tty, will convert them into
-    win32 function calls.
-    '''
-    ANSI_RE = re.compile('\033\[((?:\d|;)*)([a-zA-Z])')
-
-    def __init__(self, wrapped, convert=None, strip=None, autoreset=False):
-        # The wrapped stream (normally sys.stdout or sys.stderr)
-        self.wrapped = wrapped
-
-        # should we reset colors to defaults after every .write()
-        self.autoreset = autoreset
-
-        # create the proxy wrapping our output stream
-        self.stream = StreamWrapper(wrapped, self)
-
-        on_windows = sys.platform.startswith('win')
-
-        # should we strip ANSI sequences from our output?
-        if strip is None:
-            strip = on_windows
-        self.strip = strip
-
-        # should we should convert ANSI sequences into win32 calls?
-        if convert is None:
-            convert = on_windows and is_a_tty(wrapped)
-        self.convert = convert
-
-        # dict of ansi codes to win32 functions and parameters
-        self.win32_calls = self.get_win32_calls()
-
-        # are we wrapping stderr?
-        self.on_stderr = self.wrapped is sys.stderr
-
-
-    def should_wrap(self):
-        '''
-        True if this class is actually needed. If false, then the output
-        stream will not be affected, nor will win32 calls be issued, so
-        wrapping stdout is not actually required. This will generally be
-        False on non-Windows platforms, unless optional functionality like
-        autoreset has been requested using kwargs to init()
-        '''
-        return self.convert or self.strip or self.autoreset
-
-
-    def get_win32_calls(self):
-        if self.convert and winterm:
-            return {
-                AnsiStyle.RESET_ALL: (winterm.reset_all, ),
-                AnsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),
-                AnsiStyle.DIM: (winterm.style, WinStyle.NORMAL),
-                AnsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),
-                AnsiFore.BLACK: (winterm.fore, WinColor.BLACK),
-                AnsiFore.RED: (winterm.fore, WinColor.RED),
-                AnsiFore.GREEN: (winterm.fore, WinColor.GREEN),
-                AnsiFore.YELLOW: (winterm.fore, WinColor.YELLOW),
-                AnsiFore.BLUE: (winterm.fore, WinColor.BLUE),
-                AnsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),
-                AnsiFore.CYAN: (winterm.fore, WinColor.CYAN),
-                AnsiFore.WHITE: (winterm.fore, WinColor.GREY),
-                AnsiFore.RESET: (winterm.fore, ),
-                AnsiBack.BLACK: (winterm.back, WinColor.BLACK),
-                AnsiBack.RED: (winterm.back, WinColor.RED),
-                AnsiBack.GREEN: (winterm.back, WinColor.GREEN),
-                AnsiBack.YELLOW: (winterm.back, WinColor.YELLOW),
-                AnsiBack.BLUE: (winterm.back, WinColor.BLUE),
-                AnsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),
-                AnsiBack.CYAN: (winterm.back, WinColor.CYAN),
-                AnsiBack.WHITE: (winterm.back, WinColor.GREY),
-                AnsiBack.RESET: (winterm.back, ),
-            }
-
-
-    def write(self, text):
-        if self.strip or self.convert:
-            self.write_and_convert(text)
-        else:
-            self.wrapped.write(text)
-            self.wrapped.flush()
-        if self.autoreset:
-            self.reset_all()
-
-
-    def reset_all(self):
-        if self.convert:
-            self.call_win32('m', (0,))
-        elif is_a_tty(self.wrapped):
-            self.wrapped.write(Style.RESET_ALL)
-
-
-    def write_and_convert(self, text):
-        '''
-        Write the given text to our wrapped stream, stripping any ANSI
-        sequences from the text, and optionally converting them into win32
-        calls.
-        '''
-        cursor = 0
-        for match in self.ANSI_RE.finditer(text):
-            start, end = match.span()
-            self.write_plain_text(text, cursor, start)
-            self.convert_ansi(*match.groups())
-            cursor = end
-        self.write_plain_text(text, cursor, len(text))
-
-
-    def write_plain_text(self, text, start, end):
-        if start < end:
-            self.wrapped.write(text[start:end])
-            self.wrapped.flush()
-
-
-    def convert_ansi(self, paramstring, command):
-        if self.convert:
-            params = self.extract_params(paramstring)
-            self.call_win32(command, params)
-
-
-    def extract_params(self, paramstring):
-        def split(paramstring):
-            for p in paramstring.split(';'):
-                if p != '':
-                    yield int(p)
-        return tuple(split(paramstring))
-
-
-    def call_win32(self, command, params):
-        if params == []:
-            params = [0]
-        if command == 'm':
-            for param in params:
-                if param in self.win32_calls:
-                    func_args = self.win32_calls[param]
-                    func = func_args[0]
-                    args = func_args[1:]
-                    kwargs = dict(on_stderr=self.on_stderr)
-                    func(*args, **kwargs)
-        elif command in ('H', 'f'): # set cursor position
-            func = winterm.set_cursor_position
-            func(params, on_stderr=self.on_stderr)
-        elif command in ('J'):
-            func = winterm.erase_data
-            func(params, on_stderr=self.on_stderr)
-
diff --git a/clint/packages/colorama/initialise.py b/clint/packages/colorama/initialise.py
deleted file mode 100644
index 51aaa34..0000000
--- a/clint/packages/colorama/initialise.py
+++ /dev/null
@@ -1,55 +0,0 @@
-import atexit
-import sys
-
-from .ansitowin32 import AnsiToWin32
-
-
-orig_stdout = sys.stdout
-orig_stderr = sys.stderr
-
-wrapped_stdout = sys.stdout
-wrapped_stderr = sys.stderr
-
-atexit_done = False
-
-
-def reset_all():
-    AnsiToWin32(orig_stdout).reset_all()
-
-
-def init(autoreset=False, convert=None, strip=None, wrap=True):
-
-    if not wrap and any([autoreset, convert, strip]):
-        raise ValueError('wrap=False conflicts with any other arg=True')
-
-    global wrapped_stdout, wrapped_stderr
-    sys.stdout = wrapped_stdout = \
-        wrap_stream(orig_stdout, convert, strip, autoreset, wrap)
-    sys.stderr = wrapped_stderr = \
-        wrap_stream(orig_stderr, convert, strip, autoreset, wrap)
-
-    global atexit_done
-    if not atexit_done:
-        atexit.register(reset_all)
-        atexit_done = True
-
-
-def deinit():
-    sys.stdout = orig_stdout
-    sys.stderr = orig_stderr
-
-
-def reinit():
-    sys.stdout = wrapped_stdout
-    sys.stderr = wrapped_stdout
-
-
-def wrap_stream(stream, convert, strip, autoreset, wrap):
-    if wrap:
-        wrapper = AnsiToWin32(stream,
-            convert=convert, strip=strip, autoreset=autoreset)
-        if wrapper.should_wrap():
-            stream = wrapper.stream
-    return stream
-
-
diff --git a/clint/packages/colorama/win32.py b/clint/packages/colorama/win32.py
deleted file mode 100644
index ed4d613..0000000
--- a/clint/packages/colorama/win32.py
+++ /dev/null
@@ -1,123 +0,0 @@
-
-# from winbase.h
-STDOUT = -11
-STDERR = -12
-
-try:
-    from ctypes import windll
-except ImportError:
-    windll = None
-    SetConsoleTextAttribute = lambda *_: None
-else:
-    from ctypes import (
-        byref, Structure, c_char, c_short, c_uint32, c_ushort
-    )
-
-    handles = {
-        STDOUT: windll.kernel32.GetStdHandle(STDOUT),
-        STDERR: windll.kernel32.GetStdHandle(STDERR),
-    }
-
-    SHORT = c_short
-    WORD = c_ushort
-    DWORD = c_uint32
-    TCHAR = c_char
-
-    class COORD(Structure):
-        """struct in wincon.h"""
-        _fields_ = [
-            ('X', SHORT),
-            ('Y', SHORT),
-        ]
-
-    class  SMALL_RECT(Structure):
-        """struct in wincon.h."""
-        _fields_ = [
-            ("Left", SHORT),
-            ("Top", SHORT),
-            ("Right", SHORT),
-            ("Bottom", SHORT),
-        ]
-
-    class CONSOLE_SCREEN_BUFFER_INFO(Structure):
-        """struct in wincon.h."""
-        _fields_ = [
-            ("dwSize", COORD),
-            ("dwCursorPosition", COORD),
-            ("wAttributes", WORD),
-            ("srWindow", SMALL_RECT),
-            ("dwMaximumWindowSize", COORD),
-        ]
-        def __str__(self):
-            return '(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)' % (
-                self.dwSize.Y, self.dwSize.X
-                , self.dwCursorPosition.Y, self.dwCursorPosition.X
-                , self.wAttributes
-                , self.srWindow.Top, self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right
-                , self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X
-            )
-
-    def GetConsoleScreenBufferInfo(stream_id=STDOUT):
-        handle = handles[stream_id]
-        csbi = CONSOLE_SCREEN_BUFFER_INFO()
-        success = windll.kernel32.GetConsoleScreenBufferInfo(
-            handle, byref(csbi))
-        # This fails when imported via setup.py when installing using 'pip'
-        # presumably the fix is that running setup.py should not trigger all
-        # this activity.
-        # assert success
-        return csbi
-
-    def SetConsoleTextAttribute(stream_id, attrs):
-        handle = handles[stream_id]
-        return windll.kernel32.SetConsoleTextAttribute(handle, attrs)
-
-    def SetConsoleCursorPosition(stream_id, position):
-        position = COORD(*position)
-        # If the position is out of range, do nothing.
-        if position.Y <= 0 or position.X <= 0: 
-            return
-        # Adjust for Windows' SetConsoleCursorPosition:
-        #    1. being 0-based, while ANSI is 1-based.
-        #    2. expecting (x,y), while ANSI uses (y,x).
-        adjusted_position = COORD(position.Y - 1, position.X - 1)
-        # Adjust for viewport's scroll position
-        sr = GetConsoleScreenBufferInfo(STDOUT).srWindow
-        adjusted_position.Y += sr.Top
-        adjusted_position.X += sr.Left
-        # Resume normal processing
-        handle = handles[stream_id]
-        success = windll.kernel32.SetConsoleCursorPosition(handle, adjusted_position)
-        return success
-
-    def FillConsoleOutputCharacter(stream_id, char, length, start):
-        handle = handles[stream_id]
-        char = TCHAR(char)
-        length = DWORD(length)
-        num_written = DWORD(0)
-        # Note that this is hard-coded for ANSI (vs wide) bytes.
-        success = windll.kernel32.FillConsoleOutputCharacterA(
-            handle, char, length, start, byref(num_written))
-        return num_written.value
-
-    def FillConsoleOutputAttribute(stream_id, attr, length, start):
-        ''' FillConsoleOutputAttribute( hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten )'''
-        handle = handles[stream_id]
-        attribute = WORD(attr)
-        length = DWORD(length)
-        num_written = DWORD(0)
-        # Note that this is hard-coded for ANSI (vs wide) bytes.
-        success = windll.kernel32.FillConsoleOutputAttribute(
-            handle, attribute, length, start, byref(num_written))
-        return success
-
-
-if __name__=='__main__':
-    x = GetConsoleScreenBufferInfo(STDOUT)
-    print(x)
-    print('dwSize(height,width)                    = (%d,%d)' % (x.dwSize.Y, x.dwSize.X))
-    print('dwCursorPosition(y,x)                   = (%d,%d)' % (x.dwCursorPosition.Y, x.dwCursorPosition.X))
-    print('wAttributes(color)                      =  %d = 0x%02x' % (x.wAttributes, x.wAttributes))
-    print('srWindow(Top,Left)-(Bottom,Right)       = (%d,%d)-(%d,%d)' % (x.srWindow.Top, x.srWindow.Left, x.srWindow.Bottom, x.srWindow.Right))
-    print('dwMaximumWindowSize(maxHeight,maxWidth) = (%d,%d)' % (x.dwMaximumWindowSize.Y, x.dwMaximumWindowSize.X))
-
diff --git a/clint/packages/colorama/winterm.py b/clint/packages/colorama/winterm.py
deleted file mode 100644
index 95585f3..0000000
--- a/clint/packages/colorama/winterm.py
+++ /dev/null
@@ -1,102 +0,0 @@
-
-from . import win32
-
-
-# from wincon.h
-class WinColor(object):
-    BLACK   = 0
-    BLUE    = 1
-    GREEN   = 2
-    CYAN    = 3
-    RED     = 4
-    MAGENTA = 5
-    YELLOW  = 6
-    GREY    = 7
-
-# from wincon.h
-class WinStyle(object):
-    NORMAL = 0x00 # dim text, dim background
-    BRIGHT = 0x08 # bright text, dim background
-
-
-class WinTerm(object):
-
-    def __init__(self):
-        self._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes
-        self.set_attrs(self._default)
-        self._default_fore = self._fore
-        self._default_back = self._back
-        self._default_style = self._style
-
-    def get_attrs(self):
-        return self._fore + self._back * 16 + self._style
-
-    def set_attrs(self, value):
-        self._fore = value & 7
-        self._back = (value >> 4) & 7
-        self._style = value & WinStyle.BRIGHT
-
-    def reset_all(self, on_stderr=None):
-        self.set_attrs(self._default)
-        self.set_console(attrs=self._default)
-
-    def fore(self, fore=None, on_stderr=False):
-        if fore is None:
-            fore = self._default_fore
-        self._fore = fore
-        self.set_console(on_stderr=on_stderr)
-
-    def back(self, back=None, on_stderr=False):
-        if back is None:
-            back = self._default_back
-        self._back = back
-        self.set_console(on_stderr=on_stderr)
-
-    def style(self, style=None, on_stderr=False):
-        if style is None:
-            style = self._default_style
-        self._style = style
-        self.set_console(on_stderr=on_stderr)
-
-    def set_console(self, attrs=None, on_stderr=False):
-        if attrs is None:
-            attrs = self.get_attrs()
-        handle = win32.STDOUT
-        if on_stderr:
-            handle = win32.STDERR
-        win32.SetConsoleTextAttribute(handle, attrs)
-
-    def set_cursor_position(self, position=None, on_stderr=False):
-        if position is None:
-            #I'm not currently tracking the position, so there is no default.
-            #position = self.get_position()
-            return
-        handle = win32.STDOUT
-        if on_stderr:
-            handle = win32.STDERR
-        win32.SetConsoleCursorPosition(handle, position)
-
-    def erase_data(self, mode=0, on_stderr=False):
-        # 0 (or None) should clear from the cursor to the end of the screen.
-        # 1 should clear from the cursor to the beginning of the screen.
-        # 2 should clear the entire screen. (And maybe move cursor to (1,1)?)
-        #
-        # At the moment, I only support mode 2. From looking at the API, it 
-        #    should be possible to calculate a different number of bytes to clear, 
-        #    and to do so relative to the cursor position.
-        if mode[0] not in (2,):
-            return
-        handle = win32.STDOUT
-        if on_stderr:
-            handle = win32.STDERR
-        # here's where we'll home the cursor
-        coord_screen = win32.COORD(0,0) 
-        csbi = win32.GetConsoleScreenBufferInfo(handle)
-        # get the number of character cells in the current buffer
-        dw_con_size = csbi.dwSize.X * csbi.dwSize.Y
-        # fill the entire screen with blanks
-        win32.FillConsoleOutputCharacter(handle, ord(' '), dw_con_size, coord_screen)
-        # now set the buffer's attributes accordingly
-        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), dw_con_size, coord_screen );
-        # put the cursor at (0, 0)
-        win32.SetConsoleCursorPosition(handle, (coord_screen.X, coord_screen.Y))
diff --git a/clint/packages/ordereddict.py b/clint/packages/ordereddict.py
deleted file mode 100644
index 5b0303f..0000000
--- a/clint/packages/ordereddict.py
+++ /dev/null
@@ -1,127 +0,0 @@
-# Copyright (c) 2009 Raymond Hettinger
-#
-# Permission is hereby granted, free of charge, to any person
-# obtaining a copy of this software and associated documentation files
-# (the "Software"), to deal in the Software without restriction,
-# including without limitation the rights to use, copy, modify, merge,
-# publish, distribute, sublicense, and/or sell copies of the Software,
-# and to permit persons to whom the Software is furnished to do so,
-# subject to the following conditions:
-#
-#     The above copyright notice and this permission notice shall be
-#     included in all copies or substantial portions of the Software.
-#
-#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
-#     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-#     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-#     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-#     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-#     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-#     OTHER DEALINGS IN THE SOFTWARE.
-
-from UserDict import DictMixin
-
-class OrderedDict(dict, DictMixin):
-
-    def __init__(self, *args, **kwds):
-        if len(args) > 1:
-            raise TypeError('expected at most 1 arguments, got %d' % len(args))
-        try:
-            self.__end
-        except AttributeError:
-            self.clear()
-        self.update(*args, **kwds)
-
-    def clear(self):
-        self.__end = end = []
-        end += [None, end, end]         # sentinel node for doubly linked list
-        self.__map = {}                 # key --> [key, prev, next]
-        dict.clear(self)
-
-    def __setitem__(self, key, value):
-        if key not in self:
-            end = self.__end
-            curr = end[1]
-            curr[2] = end[1] = self.__map[key] = [key, curr, end]
-        dict.__setitem__(self, key, value)
-
-    def __delitem__(self, key):
-        dict.__delitem__(self, key)
-        key, prev, next = self.__map.pop(key)
-        prev[2] = next
-        next[1] = prev
-
-    def __iter__(self):
-        end = self.__end
-        curr = end[2]
-        while curr is not end:
-            yield curr[0]
-            curr = curr[2]
-
-    def __reversed__(self):
-        end = self.__end
-        curr = end[1]
-        while curr is not end:
-            yield curr[0]
-            curr = curr[1]
-
-    def popitem(self, last=True):
-        if not self:
-            raise KeyError('dictionary is empty')
-        if last:
-            key = reversed(self).next()
-        else:
-            key = iter(self).next()
-        value = self.pop(key)
-        return key, value
-
-    def __reduce__(self):
-        items = [[k, self[k]] for k in self]
-        tmp = self.__map, self.__end
-        del self.__map, self.__end
-        inst_dict = vars(self).copy()
-        self.__map, self.__end = tmp
-        if inst_dict:
-            return (self.__class__, (items,), inst_dict)
-        return self.__class__, (items,)
-
-    def keys(self):
-        return list(self)
-
-    setdefault = DictMixin.setdefault
-    update = DictMixin.update
-    pop = DictMixin.pop
-    values = DictMixin.values
-    items = DictMixin.items
-    iterkeys = DictMixin.iterkeys
-    itervalues = DictMixin.itervalues
-    iteritems = DictMixin.iteritems
-
-    def __repr__(self):
-        if not self:
-            return '%s()' % (self.__class__.__name__,)
-        return '%s(%r)' % (self.__class__.__name__, self.items())
-
-    def copy(self):
-        return self.__class__(self)
-
-    @classmethod
-    def fromkeys(cls, iterable, value=None):
-        d = cls()
-        for key in iterable:
-            d[key] = value
-        return d
-
-    def __eq__(self, other):
-        if isinstance(other, OrderedDict):
-            if len(self) != len(other):
-                return False
-            for p, q in  zip(self.items(), other.items()):
-                if p != q:
-                    return False
-            return True
-        return dict.__eq__(self, other)
-
-    def __ne__(self, other):
-        return not self == other
diff --git a/setup.py b/setup.py
index 8b306e1..9f8ed4a 100755
--- a/setup.py
+++ b/setup.py
@@ -33,7 +33,6 @@ setup(
     packages= [
         'clint',
         'clint.textui',
-        'clint.packages', 'clint.packages.colorama'
     ],
     install_requires=required,
     license='ISC',
-- 
2.7.4

